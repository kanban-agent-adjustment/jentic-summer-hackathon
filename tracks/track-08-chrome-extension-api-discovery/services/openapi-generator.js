/**
 * OpenAPI Generator Library
 * Generates OpenAPI 3.0 specifications from discovered APIs
 */

import { analyzeAPIPatterns, generateInsights } from './api-analyzer.js';

// Generate OpenAPI specification from discovered APIs
export function generateOpenAPISpec(apis) {
    if (!apis || apis.length === 0) {
        throw new Error('No APIs provided for OpenAPI generation');
    }
    
    // Analyze APIs to extract patterns
    const analysis = analyzeAPIPatterns(apis);
    const insights = generateInsights(analysis);
    
    // Generate base OpenAPI structure
    const spec = {
        openapi: '3.0.3',
        info: generateInfo(apis, analysis),
        servers: generateServers(analysis.baseUrls),
        paths: generatePaths(apis, analysis),
        components: generateComponents(apis, analysis),
        tags: generateTags(analysis.groups),
        externalDocs: generateExternalDocs(apis)
    };
    
    return JSON.stringify(spec, null, 2);
}

// Generate API info section
function generateInfo(apis, analysis) {
    const baseUrl = analysis.baseUrls[0]?.url || 'https://api.example.com';
    const domain = new URL(baseUrl).hostname;
    
    return {
        title: `${domain} API`,
        description: generateDescription(apis, analysis),
        version: '1.0.0',
        contact: {
            name: 'API Discovery Extension',
            url: 'https://github.com/jentic-hackathon/chrome-extension-api-discovery'
        },
        license: {
            name: 'MIT',
            url: 'https://opensource.org/licenses/MIT'
        }
    };
}

// Generate API description
function generateDescription(apis, analysis) {
    const totalAPIs = apis.length;
    const methods = analysis.methodUsage.map(m => m.method).join(', ');
    const baseUrls = analysis.baseUrls.length;
    
    let description = `Auto-generated OpenAPI specification for ${analysis.baseUrls[0]?.url || 'discovered API'}.\n\n`;
    description += `## Discovery Summary\n`;
    description += `- **Total Endpoints**: ${totalAPIs}\n`;
    description += `- **HTTP Methods**: ${methods}\n`;
    description += `- **Base URLs**: ${baseUrls}\n`;
    
    if (analysis.authentication.bearer > 0) {
        description += `- **Authentication**: Bearer Token\n`;
    } else if (analysis.authentication.apiKey > 0) {
        description += `- **Authentication**: API Key\n`;
    } else if (analysis.authentication.basic > 0) {
        description += `- **Authentication**: Basic Auth\n`;
    } else {
        description += `- **Authentication**: None required\n`;
    }
    
    if (analysis.rateLimiting.hasRateLimiting) {
        description += `- **Rate Limiting**: Yes\n`;
    }
    
    description += `\n## Generated by\n`;
    description += `This specification was automatically generated by the API Discovery Chrome Extension.`;
    
    return description;
}

// Generate servers section
function generateServers(baseUrls) {
    if (!baseUrls || baseUrls.length === 0) {
        return [{ url: 'https://api.example.com' }];
    }
    
    return baseUrls.map(baseUrl => ({
        url: baseUrl.url,
        description: `Base URL with ${baseUrl.count} endpoints`
    }));
}

// Generate paths section
function generatePaths(apis, analysis) {
    const paths = {};
    
    // Group APIs by path pattern
    const pathGroups = groupAPIsByPath(apis);
    
    pathGroups.forEach(group => {
        const path = group.path;
        const pathItem = generatePathItem(group.apis, analysis);
        
        if (pathItem) {
            paths[path] = pathItem;
        }
    });
    
    return paths;
}

// Group APIs by normalized path
function groupAPIsByPath(apis) {
    const groups = new Map();
    
    apis.forEach(api => {
        try {
            const url = new URL(api.url);
            const path = normalizePath(url.pathname);
            
            if (!groups.has(path)) {
                groups.set(path, {
                    path,
                    apis: []
                });
            }
            
            groups.get(path).apis.push(api);
        } catch (error) {
            console.log('Error grouping API by path:', error);
        }
    });
    
    return Array.from(groups.values());
}

// Normalize path by replacing IDs with parameters
function normalizePath(path) {
    const segments = path.split('/');
    
    return segments.map(segment => {
        // Replace numeric IDs
        if (segment.match(/^\d+$/)) {
            return '{id}';
        }
        // Replace UUIDs
        if (segment.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i)) {
            return '{uuid}';
        }
        // Replace other ID patterns
        if (segment.match(/^[0-9a-f]{8,}$/i)) {
            return '{id}';
        }
        return segment;
    }).join('/');
}

// Generate path item for a group of APIs
function generatePathItem(apis, analysis) {
    const pathItem = {};
    
    // Group by HTTP method
    const methodGroups = groupAPIsByMethod(apis);
    
    Object.entries(methodGroups).forEach(([method, methodAPIs]) => {
        const operation = generateOperation(method, methodAPIs, analysis);
        if (operation) {
            pathItem[method.toLowerCase()] = operation;
        }
    });
    
    return Object.keys(pathItem).length > 0 ? pathItem : null;
}

// Group APIs by HTTP method
function groupAPIsByMethod(apis) {
    const groups = {};
    
    apis.forEach(api => {
        const method = api.method.toLowerCase();
        if (!groups[method]) {
            groups[method] = [];
        }
        groups[method].push(api);
    });
    
    return groups;
}

// Generate operation object
function generateOperation(method, apis, analysis) {
    const api = apis[0]; // Use first API as template
    const successResponses = apis.filter(a => a.statusCode >= 200 && a.statusCode < 300);
    const errorResponses = apis.filter(a => a.statusCode >= 400);
    
    const operation = {
        summary: generateOperationSummary(method, api),
        description: generateOperationDescription(method, apis),
        operationId: generateOperationId(method, api),
        tags: generateOperationTags(api, analysis),
        parameters: generateParameters(api),
        responses: generateResponses(successResponses, errorResponses),
        security: generateSecurity(api)
    };
    
    // Add request body for POST/PUT/PATCH
    if (['post', 'put', 'patch'].includes(method)) {
        const requestBody = generateRequestBody(api);
        if (requestBody) {
            operation.requestBody = requestBody;
        }
    }
    
    return operation;
}

// Generate operation summary
function generateOperationSummary(method, api) {
    const path = api.path;
    const segments = path.split('/').filter(s => s.length > 0);
    
    switch (method) {
        case 'get':
            if (segments.includes('{id}')) {
                return `Get ${segments[segments.length - 2] || 'item'} by ID`;
            }
            return `Get ${segments[segments.length - 1] || 'items'}`;
        case 'post':
            return `Create ${segments[segments.length - 1] || 'item'}`;
        case 'put':
            return `Update ${segments[segments.length - 2] || 'item'} by ID`;
        case 'patch':
            return `Partially update ${segments[segments.length - 2] || 'item'} by ID`;
        case 'delete':
            return `Delete ${segments[segments.length - 2] || 'item'} by ID`;
        default:
            return `${method.toUpperCase()} ${path}`;
    }
}

// Generate operation description
function generateOperationDescription(method, apis) {
    const count = apis.length;
    const successCount = apis.filter(a => a.statusCode >= 200 && a.statusCode < 300).length;
    const successRate = ((successCount / count) * 100).toFixed(1);
    
    return `This endpoint was discovered ${count} time(s) with a ${successRate}% success rate.`;
}

// Generate operation ID
function generateOperationId(method, api) {
    const path = api.path;
    const segments = path.split('/').filter(s => s.length > 0);
    
    let resource = segments[segments.length - 1] || 'item';
    if (resource.includes('{')) {
        resource = segments[segments.length - 2] || 'item';
    }
    
    return `${method}${resource.charAt(0).toUpperCase() + resource.slice(1)}`;
}

// Generate operation tags
function generateOperationTags(api, analysis) {
    const tags = [];
    
    // Find matching group
    const group = analysis.groups.find(g => 
        g.apis.some(a => a.url === api.url)
    );
    
    if (group && group.name !== 'unknown') {
        tags.push(group.name);
    }
    
    return tags;
}

// Generate parameters
function generateParameters(api) {
    const parameters = [];
    
    try {
        const url = new URL(api.url);
        const path = url.pathname;
        const segments = path.split('/');
        
        // Path parameters
        segments.forEach((segment, index) => {
            if (segment.includes('{') || segment.match(/^\d+$/) || segment.match(/^[0-9a-f]{8,}$/i)) {
                parameters.push({
                    name: segment.replace(/[{}]/g, ''),
                    in: 'path',
                    required: true,
                    schema: {
                        type: 'string',
                        description: 'Resource identifier'
                    }
                });
            }
        });
        
        // Query parameters
        url.searchParams.forEach((value, key) => {
            parameters.push({
                name: key,
                in: 'query',
                required: false,
                schema: {
                    type: 'string',
                    description: `Query parameter: ${key}`
                }
            });
        });
        
    } catch (error) {
        console.log('Error generating parameters:', error);
    }
    
    return parameters;
}

// Generate responses
function generateResponses(successResponses, errorResponses) {
    const responses = {};
    
    // Success responses
    if (successResponses.length > 0) {
        const successCodes = [...new Set(successResponses.map(r => r.statusCode))];
        
        successCodes.forEach(code => {
            responses[code] = {
                description: getStatusDescription(code),
                content: {
                    'application/json': {
                        schema: {
                            type: 'object',
                            description: 'Response data'
                        }
                    }
                }
            };
        });
    } else {
        // Default success response
        responses['200'] = {
            description: 'Successful response',
            content: {
                'application/json': {
                    schema: {
                        type: 'object',
                        description: 'Response data'
                    }
                }
            }
        };
    }
    
    // Error responses
    const errorCodes = [...new Set(errorResponses.map(r => r.statusCode))];
    errorCodes.forEach(code => {
        responses[code] = {
            description: getStatusDescription(code),
            content: {
                'application/json': {
                    schema: {
                        type: 'object',
                        properties: {
                            error: {
                                type: 'string',
                                description: 'Error message'
                            }
                        }
                    }
                }
            }
        };
    });
    
    return responses;
}

// Generate request body
function generateRequestBody(api) {
    // For now, return a basic schema
    // In a full implementation, you could analyze actual request bodies
    return {
        required: true,
        content: {
            'application/json': {
                schema: {
                    type: 'object',
                    description: 'Request payload'
                }
            }
        }
    };
}

// Generate security
function generateSecurity(api) {
    const headers = api.requestHeaders || [];
    const authHeader = headers.find(h => h.name.toLowerCase() === 'authorization');
    
    if (authHeader) {
        const value = authHeader.value.toLowerCase();
        
        if (value.startsWith('bearer ')) {
            return [{ bearerAuth: [] }];
        } else if (value.startsWith('basic ')) {
            return [{ basicAuth: [] }];
        }
    }
    
    // Check for API key
    const hasApiKey = headers.some(h => 
        h.name.toLowerCase().includes('key') ||
        h.name.toLowerCase().includes('token')
    );
    
    if (hasApiKey) {
        return [{ apiKeyAuth: [] }];
    }
    
    return [];
}

// Generate components section
function generateComponents(apis, analysis) {
    return {
        securitySchemes: generateSecuritySchemes(apis),
        schemas: generateSchemas(apis),
        parameters: generateCommonParameters(apis)
    };
}

// Generate security schemes
function generateSecuritySchemes(apis) {
    const schemes = {};
    
    // Check for Bearer token
    const hasBearer = apis.some(api => 
        (api.requestHeaders || []).some(h => 
            h.name.toLowerCase() === 'authorization' && 
            h.value.toLowerCase().startsWith('bearer ')
        )
    );
    
    if (hasBearer) {
        schemes.bearerAuth = {
            type: 'http',
            scheme: 'bearer',
            bearerFormat: 'JWT'
        };
    }
    
    // Check for API key
    const hasApiKey = apis.some(api => 
        (api.requestHeaders || []).some(h => 
            h.name.toLowerCase().includes('key') ||
            h.name.toLowerCase().includes('token')
        )
    );
    
    if (hasApiKey) {
        schemes.apiKeyAuth = {
            type: 'apiKey',
            in: 'header',
            name: 'X-API-Key'
        };
    }
    
    return schemes;
}

// Generate schemas
function generateSchemas(apis) {
    // For now, return basic schemas
    // In a full implementation, you could analyze response bodies
    return {
        Error: {
            type: 'object',
            properties: {
                error: {
                    type: 'string',
                    description: 'Error message'
                },
                code: {
                    type: 'string',
                    description: 'Error code'
                }
            }
        }
    };
}

// Generate common parameters
function generateCommonParameters(apis) {
    return {
        IdParameter: {
            name: 'id',
            in: 'path',
            required: true,
            schema: {
                type: 'string',
                description: 'Resource identifier'
            }
        }
    };
}

// Generate tags
function generateTags(groups) {
    return groups
        .filter(group => group.name !== 'unknown')
        .map(group => ({
            name: group.name,
            description: `${group.count} endpoints for ${group.name} operations`
        }));
}

// Generate external docs
function generateExternalDocs(apis) {
    if (apis.length === 0) return null;
    
    try {
        const url = new URL(apis[0].url);
        return {
            description: 'Original API documentation',
            url: `${url.protocol}//${url.hostname}/docs`
        };
    } catch (error) {
        return null;
    }
}

// Get HTTP status description
function getStatusDescription(code) {
    const descriptions = {
        200: 'OK',
        201: 'Created',
        204: 'No Content',
        400: 'Bad Request',
        401: 'Unauthorized',
        403: 'Forbidden',
        404: 'Not Found',
        409: 'Conflict',
        422: 'Unprocessable Entity',
        429: 'Too Many Requests',
        500: 'Internal Server Error',
        502: 'Bad Gateway',
        503: 'Service Unavailable'
    };
    
    return descriptions[code] || `HTTP ${code}`;
}
